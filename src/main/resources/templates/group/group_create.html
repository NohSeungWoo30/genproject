<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>그룹 생성</title>
    <style>
        /* 간략한 스타일은 가독성을 위해 추가했습니다. 디자인 목적은 아닙니다. */
        body { font-family: Arial, sans-serif; margin: 20px; }
        form { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        div { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"],
        input[type="number"],
        input[type="date"],
        textarea,
        select {
            width: calc(100% - 10px); /* 패딩 고려 */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box; /* 패딩이 너비에 포함되도록 */
        }
        input[type="radio"] { margin-right: 5px; }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }

        /* 성별 라디오 버튼 한 줄 정렬 */
        .gender-options {
            display: flex;
            align-items: center;
            gap: 15px; /* 라디오 버튼 사이 간격 */
        }
        .gender-options label {
            display: inline-block; /* 라디오 버튼 라벨을 인라인으로 */
            margin-bottom: 0;
            font-weight: normal; /* 라벨 볼드 해제 */
        }

        /* 슬라이더 컨테이너 스타일 */
        .age-slider-container {
            margin-top: 25px; /* 슬라이더와 위쪽 요소 간격 */
            margin-bottom: 30px; /* 슬라이더와 아래쪽 요소 간격 */
            padding: 0 10px; /* 슬라이더가 폼 경계에 붙지 않도록 좌우 패딩 */
        }
        #age-slider-values {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        /* 최소/최대 인원수 드롭다운을 한 줄로 정렬 */
        .member-count-options {
            display: flex;
            align-items: center;
            gap: 20px; /* 드롭다운 사이 간격 */
        }
        .member-count-options > div {
            flex: 1; /* 각 드롭다운이 공간을 균등하게 차지하도록 */
        }
        .member-count-options label {
            margin-bottom: 5px;
        }
        .member-count-options select {
            width: 100%; /* 부모 div에 맞춰 100% 너비 */
        }

    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
</head>
<body>
<a href="/group/group_main" class="nav-button">그룹 목록 보기</a>
<h1>새 그룹 생성</h1>

<form action="/group/group_success" method="post">
    <div>
        <label for="ownerIdx">닉네임(nickname) :</label>
        <input type="number" id="ownerIdx" name="ownerIdx" required th:value="${group.ownerIdx}" readonly>
        <input type="text" id="nickname" name="nickname" required th:value="${nickname}" readonly>
    </div>

    <div>
        <label for="groupCategoryMainIdx">카테고리 (필수):</label>
        <select id="groupCategoryMainIdx" name="groupCategoryMainIdx">
            <option value="">-- 대분류 선택 --</option>
            <option th:each="maincategory : ${categoryMainList}"
                    th:value="${maincategory.cmCategoryMainIdx}"
                    th:text="${maincategory.cmCategoryMainIdx}+', '+${maincategory.categoryMainName}">
            </option>
        </select>
    </div>

    <div>
        <label for="groupCategorySubIdx">상세내용 (필수):</label>
        <select id="groupCategorySubIdx" name="groupCategorySubIdx">
            <option value="">-- 카테고리부터 선택 해주세요 --</option>
        </select>
    </div>

    <div>
        <label for="title">그룹 제목 (title):</label>
        <input type="text" id="title" name="title" maxlength="100" required>
    </div>

    <div>
        <label>성별 제한 (gender_limit):</label><br>
        <div class="gender-options">
            <input type="radio" id="genderM" name="genderLimit" value="M">
            <label for="genderM">남성</label>
            <input type="radio" id="genderF" name="genderLimit" value="F">
            <label for="genderF">여성</label>
            <input type="radio" id="genderNone" name="genderLimit" value="A" checked> <label for="genderNone">제한
            없음</label>
        </div>
    </div>

    <div>
        <label for="age-slider">나이 제한 (age_min ~ age_max):</label>
        <div class="age-slider-container">
            <div id="age-slider"></div>
            <div id="age-slider-values">
                <span id="ageMinDisplay">0</span> ~ <span id="ageMaxDisplay">100</span>
            </div>
        </div>
        <input type="hidden" id="ageMin" name="ageMin" value="0">
        <input type="hidden" id="ageMax" name="ageMax" value="100">
    </div>

    <div>
        <label for="groupDate">그룹 날짜 (group_date):</label>
        <input type="date" id="groupDate" name="groupDate">
    </div>

    <div class="member-count-options">
        <div>
            <label for="membersMin">최소 멤버 수:</label>
            <select id="membersMin" name="membersMin" required>
                <option value="">-- 최소 선택 --</option>
            </select>
        </div>
        <div>
            <label for="membersMax">최대 멤버 수:</label>
            <select id="membersMax" name="membersMax" required>
                <option value="">-- 최대 선택 --</option>
            </select>
        </div>
    </div>

    <div>
        <label for="content">내용 (content):</label>
        <textarea id="content" name="content" rows="5" maxlength="1000"></textarea>
    </div>

    <h3>모임 장소 지정</h3>
    <div id="map" style="width:100%;height:400px;"></div>
    <div>
        <input type="text" id="searchPlaceInput" placeholder="장소 검색">
        <button type="button" id="searchPlaceButton">검색</button>
        <ul id="placeResultList"></ul>
    </div>
    <div>
        <label for="meetingPlaceName">선택된 장소명:</label>
        <input type="text" id="meetingPlaceName" name="meetingPlaceName" readonly>
    </div>
    <div>
        <label for="meetingPlaceAddress">선택된 주소:</label>
        <input type="text" id="meetingPlaceAddress" name="meetingPlaceAddress" readonly>
    </div>
    <input type="hidden" id="meetingPlaceLat" name="meetingPlaceLat">
    <input type="hidden" id="meetingPlaceLng" name="meetingPlaceLng">

    <div>
        <button type="submit">그룹 생성</button>
    </div>

</form>

<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<!--<script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=s2hofoc0b5&submodules=geocoder&callback=initMap"></script>-->
<script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=s2hofoc0b5&submodules=geocoder&callback=initMap"></script>
<script th:inline="javascript">
    // --- 전역 변수 선언 ---
    let map = null; // 지도 객체
    let markers = []; // 마커 배열
    let placeResultList = null; // placeResultList 요소를 저장할 변수

    // 폼 필드 참조 (initMap에서 할당)
    let meetingPlaceNameInput = null;
    let meetingPlaceAddressInput = null;
    let meetingPlaceLatInput = null;
    let meetingPlaceLngInput = null;
    let searchPlaceInput = null;
    let searchPlaceButton = null;

    // --- 헬퍼 함수 ---

    // 마커 지우는 함수
    function clearMarkers() {
        for (let i = 0; i < markers.length; i++) {
            markers[i].setMap(null);
        }
        markers = [];
    }

    // 장소 선택 시 폼 필드 업데이트 함수
    function selectPlaceFromSearch(title, address, lat, lng) {
        console.log("선택된 장소:", title, address, lat, lng);
        meetingPlaceNameInput.value = title; // 'name' 대신 'title' 사용
        meetingPlaceAddressInput.value = address;
        meetingPlaceLatInput.value = lat;
        meetingPlaceLngInput.value = lng;
        alert(`선택된 장소: ${title}\n주소: ${address}\n위도: ${lat}, 경도: ${lng}`);
        map.setCenter(new naver.maps.LatLng(lat, lng)); // 선택된 장소로 지도 중심 이동
    }

    // --- 지도 및 UI 초기화 함수 (네이버 API callback으로 호출) ---
    function initMap() {
        // DOM 요소 참조 가져오기
        placeResultList = document.getElementById('placeResultList');
        meetingPlaceNameInput = document.getElementById('meetingPlaceName');
        meetingPlaceAddressInput = document.getElementById('meetingPlaceAddress');
        meetingPlaceLatInput = document.getElementById('meetingPlaceLat');
        meetingPlaceLngInput = document.getElementById('meetingPlaceLng');
        searchPlaceInput = document.getElementById('searchPlaceInput'); // 올바른 ID 사용
        searchPlaceButton = document.getElementById('searchPlaceButton');

        // 지도 초기화
        map = new naver.maps.Map('map', {
            center: new naver.maps.LatLng(37.5665, 126.9780), // 서울 시청으로 초기화
            zoom: 15,
            zoomControl: true,
            zoomControlOptions: {
                position: naver.maps.Position.TOP_RIGHT
            }
        });

        // --- 이벤트 리스너 설정 ---

        // 검색 버튼 클릭 이벤트 리스너
        if (searchPlaceButton) {
            searchPlaceButton.addEventListener('click', function() {
                const query = searchPlaceInput.value; // 올바른 변수 사용
                if (query) {
                    searchPlace(query);
                } else {
                    alert('검색어를 입력해주세요.');
                }
            });
        }

        // 검색 결과 목록 (placeResultList) 클릭 이벤트 위임 리스너
        if (placeResultList) {
            placeResultList.addEventListener('click', function(event) {
                const clickedLi = event.target.closest('li.place-result-item'); // 가장 가까운 li.place-result-item 찾기
                if (clickedLi) {
                    const title = clickedLi.dataset.title;
                    const address = clickedLi.dataset.address;
                    const lat = parseFloat(clickedLi.dataset.lat);
                    const lng = parseFloat(clickedLi.dataset.lng);
                    selectPlaceFromSearch(title, address, lat, lng);
                }
            });
        }

        // --- 기타 UI 초기화 (DOMContentLoaded에 있던 내용들을 initMap으로 이동) ---

        // 카테고리 스크립트
        const mainCategorySelect = document.getElementById('groupCategoryMainIdx');
        const subCategorySelect = document.getElementById('groupCategorySubIdx');

        mainCategorySelect.addEventListener('change', function() {
            const selectedMainCategoryIdx = this.value;
            subCategorySelect.innerHTML = '<option value="">-- 소분류 선택 --</option>';
            subCategorySelect.disabled = true;

            if (selectedMainCategoryIdx) {
                fetch(`/group/api/sub-categories?mainCategoryIdx=${selectedMainCategoryIdx}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok ' + response.statusText);
                        }
                        return response.json();
                    })
                    .then(subCategories => {
                        subCategories.forEach(category => {
                            const option = document.createElement('option');
                            option.value = category.categorySubIdx;
                            option.textContent = category.categorySubName;
                            subCategorySelect.appendChild(option);
                        });
                        subCategorySelect.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error fetching sub categories:', error);
                        alert('서브 카테고리를 불러오는 데 실패했습니다.');
                        subCategorySelect.disabled = true;
                    });
            } else {
                subCategorySelect.disabled = true;
            }
        });

        // 폼 제출 시 유효성 검사
        const form = document.querySelector('form');
        if (form) {
            form.addEventListener('submit', function(e) {
                const genderRadios = document.getElementsByName('genderLimit');
                let isGenderSelected = false;
                for (const radio of genderRadios) {
                    if (radio.checked) {
                        isGenderSelected = true;
                        break;
                    }
                }

                if (!isGenderSelected) {
                    e.preventDefault();
                    alert('성별 제한을 선택해주세요.');
                    return;
                }

                const minMembersSelect = document.getElementById('membersMin');
                const maxMembersSelect = document.getElementById('membersMax');

                const minMembers = parseInt(minMembersSelect.value);
                const maxMembers = parseInt(maxMembersSelect.value);

                if (minMembersSelect.value === "" || maxMembersSelect.value === "") {
                    e.preventDefault();
                    alert('최소/최대 멤버 수를 선택해주세요.');
                    return;
                }

                if (minMembers > maxMembers) {
                    e.preventDefault();
                    alert('최소 멤버 수는 최대 멤버 수보다 클 수 없습니다.');
                    return;
                }
            });
        }


        // 나이 슬라이더 스크립트
        const ageSlider = document.getElementById('age-slider');
        const ageMinInput = document.getElementById('ageMin');
        const ageMaxInput = document.getElementById('ageMax');
        const ageMinDisplay = document.getElementById('ageMinDisplay');
        const ageMaxDisplay = document.getElementById('ageMaxDisplay');

        if (ageSlider && ageMinInput && ageMaxInput && ageMinDisplay && ageMaxDisplay) {
            noUiSlider.create(ageSlider, {
                start: [parseInt(ageMinInput.value), parseInt(ageMaxInput.value)],
                connect: true,
                range: {
                    'min': 0,
                    'max': 100
                },
                step: 1,
                format: {
                    to: function (value) {
                        return parseInt(value);
                    },
                    from: function (value) {
                        return parseInt(value);
                    }
                }
            });

            ageSlider.noUiSlider.on('update', function (values, handle) {
                const minAge = values[0];
                const maxAge = values[1];
                ageMinInput.value = minAge;
                ageMaxInput.value = maxAge;
                ageMinDisplay.textContent = `${minAge}세`;
                ageMaxDisplay.textContent = `${maxAge}세`;
            });

            // 폼 로드 시 숨겨진 input 값과 화면 표시 동기화 (초기화)
            ageMinDisplay.textContent = `${ageMinInput.value}세`;
            ageMaxDisplay.textContent = `${ageMaxInput.value}세`;
        }


        // 최소/최대 멤버 수 옵션 동적 생성
        const minMembersSelect = document.getElementById('membersMin');
        const maxMembersSelect = document.getElementById('membersMax');

        if (minMembersSelect && maxMembersSelect) {
            const membersCountOptions = [2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 30];

            function populateSelectOptions(selectElement) {
                membersCountOptions.forEach(count => {
                    const option = document.createElement('option');
                    option.value = count;
                    option.textContent = `${count}명`;
                    selectElement.appendChild(option);
                });
            }

            populateSelectOptions(minMembersSelect);
            populateSelectOptions(maxMembersSelect);
        }
    } // --- initMap 함수 끝 ---


    // --- 키워드를 이용해 장소 검색 (백엔드 프록시 경유) ---
    async function searchPlace(query) {
        clearMarkers();
        placeResultList.innerHTML = ''; // 기존 검색 결과 초기화

        // 1. 현재 지도 화면의 영역(Bounds) 정보 가져오기
        const bounds = map.getBounds();
        console.log("bounds값 ", bounds);
        const southWest = bounds.getSW(); // 남서쪽 좌표
        const northEast = bounds.getNE(); // 북동쪽 좌표

        const southWestLat = southWest.lat();
        const southWestLng = southWest.lng();
        const northEastLat = northEast.lat();
        const northEastLng = northEast.lng();

        const displayCount = 100; // 더 많은 결과를 받아온 후 프론트에서 필터링합니다.

        // 2. 백엔드 API 호출 시 지도 영역 정보를 쿼리 파라미터로 전달
        // const apiUrl = `/api/naver/places/by-coords?query=${encodeURIComponent(query)}&lat=${currentLat}&lng=${currentLng}&display=${displayCount}`;
        const apiUrl = `/api/naver/places/by-coords?query=${encodeURIComponent(query)}&southwest_lat=${southWestLat}&southwest_lng=${southWestLng}&northeast_lat=${northEastLat}&northeast_lng=${northEastLng}&display=${displayCount}`;
        console.log("백엔드 프록시 API 요청 URL:", apiUrl);

        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
            }
            const data = await response.json();
            const items = data.items;

            if (items && items.length > 0) {
                // 지도화면이동
                const firstItemLat = parseFloat(items[0].mapy) / 1e7;
                const firstItemLng = parseFloat(items[0].mapx) / 1e7;
                const firstItemPoint = new naver.maps.LatLng(firstItemLat, firstItemLng);
                map.setCenter(firstItemPoint);

                const currentBounds = map.getBounds(); // 현재 지도의 가시 영역 (Bounds) 가져오기
                console.log("현재 지도의 범위:", currentBounds);

                let resultsInView = 0; // 화면 내에 표시된 결과 수 카운트

                items.forEach((item) => {
                    const title = item.title.replace(/<[^>]*>/g, '').replace(/&amp;/g, '&');
                    const address = item.roadAddress || item.address;
                    const lat = parseFloat(item.mapy) / 1e7;
                    const lng = parseFloat(item.mapx) / 1e7;
                    const point = new naver.maps.LatLng(lat, lng);

                    // 현재 지도 화면 범위 내에 있는지 필터링
                    if (currentBounds.hasLatLng(point)) {
                        const marker = new naver.maps.Marker({
                            position: point,
                            map: map,
                            title: title
                        });
                        markers.push(marker);

                        const li = document.createElement('li');
                        li.innerHTML = `<strong>${title}</strong><br>${address}`;
                        li.setAttribute('data-title', title);
                        li.setAttribute('data-address', address);
                        li.setAttribute('data-lat', lat);
                        li.setAttribute('data-lng', lng);
                        li.classList.add('place-result-item');

                        placeResultList.appendChild(li);
                        resultsInView++;
                    } else {
                        console.log(`[화면 밖] ${title} - ${lat}, ${lng}`);
                    }
                });

                if (resultsInView === 0) {
                    placeResultList.innerHTML = '<li>현재 지도 화면 내에 검색 결과가 없습니다.</li>';
                }

            } else {
                placeResultList.innerHTML = '<li>검색 결과가 없습니다.</li>';
            }
        } catch (error) {
            console.error('검색 중 오류 발생:', error);
            alert('장소 검색에 실패했습니다.');
        }
    }

    // --- 좌표를 이용해 장소 검색 (역지오코딩) ---
    // 이 함수는 현재 HTML에서 직접 호출되지 않지만, 유지해 두었습니다.
    function searchPlaceByCoordinates(lat, lng) {
        if (typeof naver.maps.Service === 'undefined' || typeof naver.maps.Service.reverseGeocode === 'undefined') {
            console.error("네이버 지도 Geocoder 서비스 또는 요청 상수가 아직 완전히 로드되지 않았습니다.");
            return;
        }

        const coordinate = new naver.maps.LatLng(lat, lng);
        naver.maps.Service.reverseGeocode({
            coords: coordinate,
            orders: [
                naver.maps.Service.Order.ROAD_ADDR,
                naver.maps.Service.Order.ADDR
            ]
        }, function(status, response) {
            if (status === naver.maps.Service.Status.OK) {
                let address = response.v2.address.roadAddress || response.v2.address.jibunAddress;
                let placeName = `선택된 위치 (${address})`;

                clearMarkers(); // 기존 마커 제거
                let newMarker = new naver.maps.Marker({
                    position: coordinate,
                    map: map
                });
                markers.push(newMarker);

                meetingPlaceNameInput.value = placeName;
                meetingPlaceAddressInput.value = address;
                meetingPlaceLatInput.value = lat;
                meetingPlaceLngInput.value = lng;

                alert(`선택된 장소: ${address}\n위도: ${lat}, 경도: ${lng}`);

            } else {
                alert('역지오코딩 실패: ' + response.status);
                console.error('역지오코딩 실패:', status, response);
            }
        });
    }

</script>

</body>
</html>